<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>R in the aiR! at useR! 2021</title>
    <meta charset="utf-8" />
    <meta name="author" content="Adithi R. Upadhya, Geospatial Data Analyst" />
    <meta name="date" content="2021-06-22" />
    <script src="libs/header-attrs-2.7/header-attrs.js"></script>
    <link href="libs/remark-css-0.0.1/useR.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/useR-fonts.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# R in the aiR! at useR! 2021
### Adithi R. Upadhya, Geospatial Data Analyst
### ILK Labs
### 2021-06-22

---



# Hello!

My name is Adithi, and I am a Geospatial Data Analyst at ILK Labs in Bangalore, India. This is my first useR! I use R to work with air quality data. I will present about how I use shiny to build tools to provide a workflow to analyse air quality data.


---

# R in the aiR!

&lt;img src="WWW/R.png" width="100px" /&gt;

- R and shiny are a powerful combination to work hands-on air-quality data. 

- The amount of data being collected is huge and necessitates the use of management platforms. 


???

R and shiny are the powerful couple which can be used to build interactive platform to manage and work with data collected.

With the ever-increasing global measurements of air pollutants (through stationary, mobile, low-cost, and satellite monitoring), the amount of data being collected is huge and necessitates the use of management platforms.

In an effort to address this issue, I developed two Shiny applications to analyse and visualise air-quality data.


---

# Necessity is the mother of Invention 

- Apps can be deployed

- No programming knowledge required

- Help is always around

???

Necessity is the mother of invention. Shiny apps are very accessible and user friendly, so team members across continents can use these without any prior knowledge of programming. Another added benefit is having a vibrant and supportive community using R. We, at ILK Labs always wanted to work with high dimensional data and talk air quality, to make it possible we designed and developed these applications. Both the applications have preloaded dataset to work around. 



---
class: center

# Mobile Monitoring 

![MM_paper](WWW/MM.png)

.center[Apte et. al(2017)]

???

The first shiny app "mmapshiny" helps processing high resolution air pollution data collected on a moving platform usually called mobile monitoring. So we take multiple sensors in a car, and take repeated measurements of each road in an area to generate stable high resolution air pollutant maps (usually daily). There is superior performance in estimating long-term mean concentrations when multiple repeated drives are possible.


---

# mmaqshiny
&lt;img src="WWW/mmaqshiny.png" width="100px" /&gt;

- Handles high frequency data (~ 1 Hz)

- Visualise air pollution hot spots

- Pre-processes for various instrumental sensitivities

- Joins output files from different instruments

- Reduces computational labour

- Alarms user on instrumental errors

- Near real time quality check of the data



???

mmaqshiny can handle data of the order 10,000 every day from each of the instrument, we had nearly 5. It reduces the time consumed for analysing each pollutant individually, helps in visualising the data collected on field each day, can also be used to look for pollution hotspots. Each pollutant or sensor data requires some kind of preprocessing which depends on the principle on which it operates or its mechanical setup. Eventually joins different instrument data into one single corrected file.
This really helps us in achieving the unit of analysis for the rest of the study. This app has reduced computational labour upto 3 times. Since mobile data contains a lot of spatial data, GPS data is mandatory but other files not necessary. Since the Alarm tab is also present in the app, which helps the user to give a near real time check usually after the ride, on the health of all the instruments used. This application is available as a package on CRAN.  


---
class: center

# Stationary Monitoring 

&lt;img src="WWW/SM.png" width="200px" /&gt;

.center[CSTEP, Bangalore, India]

???

The second shiny app "pollucheck" helps processing open source air pollution data usually called stationary monitoring. There are several platforms which provide open source air quality data. We built this application for users of these platforms who can have quick analysis and basic plots of air quality done and think about science. 

---

# pollucheck
&lt;img src="WWW/PolluCheck.png" width="100px" /&gt;

- sources compatible - [CPCB (specific to India)](https://app.cpcbccr.com/ccr/#/caaqm-dashboard-all/caaqm-landing), [OpenAQ](https://openaq.org/#/countries/IN?_k=5ecycz), and
[AirNow](https://www.airnow.gov/international/us-embassies-and-consulates/#India)

- Data processing options available along with different summary statistics

- Generates statistical and summary plots

- Implements linear or multilinear regression 

- Allows users to compare from two sites

???

"pollucheck" can be used for data downloaded from CPCB (only for India), OpenAQ and AirNow, it aims at generating a range of statistical plots and summary statistics with several data processing options. There are options for different averaging periods as well. It also checks for normality, generates density, Q-Q plot along with checks for trends in the time series for the selected parameter. It can implement linear or multilinear regression using the selected parameters. pollucheck allows users to upload another set of data to compare selected parameters and generate plots. It also implements two plots from the openair package. This is also made into a package and will be on its way to CRAN soon. Don't forget to check out air quality of your city using our app! 

---

# R packages shoutouts!

- `shiny`!! 

- Tidying the data: `tidyverse`

- Manipulating timestamps: `lubridate`

- Joining the file using mutating joins

- `openair`

- and many more.....


???

A huge shoutout to all the packages which made mmaqshiny and pollucheck possible. 
Manipulating different timestamp formats has been the most challenging part since there are differnt time stamp format and the tiring timezones. Integrating a number of instruments has also been a task, joining all file together to make a single file also saves a lot of time for future analysis. Tidyverse, I guess is a must in all data analysis. 


---
class: center

# Questions?

???

Please let me know if you all have any further questions? I am also available on the Lounge if you want to discuss. Have a great day ahead!

---

## Thank you and to know more or to provide feedback find me - 

Email - [adithi@ilklabs.com](adithi@ilklabs.com)

GitHub - [@adithirgis](https://github.com/adithirgis)

Twitter - [@AdithiUpadhya](https://twitter.com/AdithiUpadhya)

    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"includePresenterNotes": true,
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
